{
  "version": 3,
  "file": "svelte-bundle.css",
  "sources": [
    "../Weather.svelte"
  ],
  "sourcesContent": [
    "<script>\n  import { onMount } from \"svelte\";\n  import constants from \"./constants\";\n  import WeatherInfo from \"./WeatherInfo.svelte\";\n\n  // https://home.openweathermap.org/api_keys\n  // https://openweathermap.org/api/one-call-3#current\n\n  let days;\n  let location;\n  let focussed_day;\n  let focussed_hour;\n  let click_player;\n  const svg_height = 70;\n\n  onMount(() => {\n    const last_location = getLastLocation();\n    chooseLocation(last_location);\n  });\n\n  function chooseLocation(loc) {\n    location = constants.locations[loc];\n    localStorage.setItem(`weather_last_location`, loc);\n    getWeatherData();\n  }\n\n  function getWeatherData() {\n    days = null;\n    const cached = localStorage.getItem(`weather_${location.name}`);\n    if (cached && constants.USE_CACHE) {\n      const data = JSON.parse(cached);\n      if (Date.now() - data.now > constants.CACHE_LENGTH) {\n        getWeatherFromAPI();\n      } else {\n        console.log(\"from cache\");\n        processData(data);\n      }\n    } else {\n      getWeatherFromAPI();\n    }\n  }\n\n  function processData(data) {\n    let hourindex = 0;\n    data.daily.forEach((day, di) => {\n      const date = constants.timeToDate(day.dt);\n      const hours = data.hourly.filter(\n        (h) => constants.timeToDate(h.dt) === date\n      );\n\n      const first_hour = hours[0];\n      const mxhrs = 23;\n      if ((di == 0 || di == 2) && hours.length < mxhrs) {\n        while (hours.length < mxhrs) {\n          const c = { dt: 0, temp: false, pop: 0 };\n          if (di == 0) {\n            hours.unshift(c);\n          } else if (di == 2) {\n            hours.push(c);\n          }\n        }\n      }\n\n      hours.forEach((h) => {\n        h.time = constants.timeToHour(h.dt);\n        h.index = hourindex;\n        hourindex++;\n      });\n\n      day.hours = hours;\n\n      // day.temp_line_chart = tempLineChart(hours);\n      // day.temp_bar_chart = tempBarChart(hours);\n      day.temp_svg = tempSVGChart(hours);\n\n      if (di == 0) {\n        focusOnHour(day, first_hour);\n      }\n    });\n\n    days = data.daily;\n  }\n\n  function tempSVGChart(hours) {\n    const alltemps = hours.filter((h) => h.temp !== false).map((h) => h.temp);\n    const maxtemp = Math.max(...alltemps);\n    const lowtemp = Math.min(...alltemps);\n    let maxtaken = false;\n    let mintaken = false;\n\n    let pl = [];\n    let texts = [];\n    let temps = hours.map((h) => h.temp);\n    let lastx, lasty;\n    let polygons = [];\n    temps.forEach((temp, i) => {\n      if (temp) {\n        const x = Math.round(constants.map(i + 1, 0, temps.length, 0, 100));\n        const y =\n          Math.round(\n            constants.map(\n              temp,\n              constants.MIN_TEMP,\n              constants.MAX_TEMP,\n              svg_height,\n              0\n            ) * 10\n          ) / 10;\n\n        if (!lastx) {\n          lastx = Math.round(constants.map(i, 0, temps.length, 0, 100));\n          lasty = y;\n          pl.push(`${lastx}, ${y}`);\n        }\n        pl.push(`${x}, ${y}`);\n        if (lasty) {\n          polygons.push({\n            points: `${lastx}, ${lasty},${x}, ${y},${x}, ${svg_height},${lastx}, ${svg_height} `,\n            hour: hours[i],\n          });\n        }\n        lastx = x;\n        lasty = y;\n\n        if (temp === maxtemp && !maxtaken) {\n          maxtaken = true;\n          texts.push({\n            text: `${constants.roundTemp(temp)}°`,\n            x: lastx,\n            y: y - 6,\n          });\n        } else if (temp === lowtemp && !mintaken) {\n          mintaken = true;\n          texts.push({\n            text: `${constants.roundTemp(temp)}°`,\n            x: lastx,\n            y: y - 6,\n          });\n        }\n      }\n    });\n    const polyline = pl.join(\",\");\n\n    return {\n      polyline,\n      polygons,\n      texts,\n    };\n  }\n\n  function tempBarChart(hours) {\n    const alltemps = hours.filter((h) => h.temp !== false).map((h) => h.temp);\n    const maxtemp = Math.max(...alltemps);\n    const lowtemp = Math.min(...alltemps);\n    let maxtaken = false;\n    let mintaken = false;\n    const bc = hours.map((h) => {\n      const ct = constants.constrain(\n        h.temp,\n        constants.MIN_TEMP,\n        constants.MAX_TEMP\n      );\n      const he =\n        h.temp === false\n          ? 0\n          : constants.map(ct, constants.MIN_TEMP, constants.MAX_TEMP, 3, 100);\n\n      let rt = false;\n      if (h.temp === maxtemp && !maxtaken) {\n        maxtaken = true;\n        rt = `${constants.roundTemp(h.temp)}°`;\n      } else if (h.temp === lowtemp && !mintaken) {\n        mintaken = true;\n        rt = `${constants.roundTemp(h.temp)}°`;\n      }\n      return {\n        value: `${constants.roundTemp(h.temp)}`,\n        height: he,\n        rt: rt,\n        hour: h,\n      };\n    });\n\n    return bc;\n  }\n\n  function tempLineChart(hours) {\n    let temps = hours.map((h) => h.temp);\n    let txy = [];\n    let oldx, oldy;\n    temps.forEach((temp, i) => {\n      const x = (i / temps.length) * 100;\n      const y = constants.map(\n        temp,\n        constants.MIN_TEMP,\n        constants.MAX_TEMP,\n        0,\n        100\n      );\n\n      if (oldx && x) {\n        var a = oldx - x;\n        var b = oldy - y;\n        var length = Math.sqrt(a * a + b * b);\n        var theta = (Math.atan2(y - oldy, x - oldx) * 180) / Math.PI;\n        txy.push({ value: temp, x, y, oldx, oldy, length, theta });\n      }\n\n      oldx = x;\n      oldy = y;\n    });\n    return txy;\n  }\n\n  function getWeatherFromAPI() {\n    console.log(\"fromapi\");\n    // const action = `https://api.openweathermap.org/data/2.5/forecast/daily\n    // ?lat=${location.lat}&lon=${location.lng}&cnt=7&appid=${constants.api_key}&units=metric`;\n\n    const action = `https://api.openweathermap.org/data/3.0/onecall?lat=${location.lat}&lon=${location.lng}&exclude=minutely&appid=${constants.api_key}&units=metric`;\n\n    constants\n      .doFetch(action, \"GET\", null)\n      .then((response) => {\n        const data = response;\n        processData(data);\n\n        response.now = Date.now();\n        const r = JSON.stringify(response);\n        localStorage.setItem(`weather_${location.name}`, r);\n      })\n      .catch((error) => {\n        console.log(error);\n      });\n  }\n\n  function getLastLocation() {\n    const l = localStorage.getItem(`weather_last_location`);\n    if (!l || l == \"\" || l == undefined) {\n      return \"woolwich\";\n    } else {\n      return l;\n    }\n  }\n\n  function focusOnHourByPos(event, day) {\n    let tar = event.target;\n\n    // 'UL'\n    while (tar.nodeName !== \"svg\") {\n      tar = tar.parentElement;\n    }\n\n    const xx = event.touches ? event.touches[0].clientX : event.clientX;\n    if (xx) {\n      const bb = tar.getBoundingClientRect();\n      const w = bb.width;\n      const x = xx - bb.left;\n      const p = x / w;\n      const hl = day.hours.length;\n      const ind = Math.floor(p * hl);\n      const hr = day.hours[ind];\n      if (hr) {\n        if (hr.temp) {\n          focusOnHour(day, day.hours[ind]);\n        }\n      }\n    }\n  }\n\n  function focusOnHour(day, hour) {\n    focussed_hour = hour;\n    focussed_day = day;\n    // playClick();\n  }\n\n  function playClick() {\n    if (click_player) {\n      click_player.volume = 0.5;\n      click_player.currentTime = 0;\n      click_player.play();\n    }\n  }\n\n  function loadClick() {\n    click_player = new Audio(constants.click_file);\n  }\n\n  function handleKeyUp(e) {\n    if (e.key == \"ArrowRight\" || e.key == \"ArrowLeft\") {\n      if (focussed_hour) {\n        let diff = e.key == \"ArrowRight\" ? 1 : -1;\n        const newindex = focussed_hour.index + diff;\n        let hourchange = null;\n        let daychange = null;\n        days.forEach((day) => {\n          const newhour = day.hours.find((h) => h.index == newindex && h.temp);\n          if (newhour) {\n            daychange = day;\n            hourchange = newhour;\n          }\n        });\n        if (hourchange) {\n          focusOnHour(daychange, hourchange);\n        }\n      }\n    }\n  }\n</script>\n\n<!-- <svelte:head><title>Hello</title></svelte:head> -->\n<svelte:body on:keyup={handleKeyUp} />\n\n<div class:animated={constants.ANIMATED_ICONS}>\n  {#if days}\n    <section id=\"seven_days\">\n      {#each days as day, di}\n        {#if di < 7}\n          <div class=\"day weather_{day.weather[0].icon}\">\n            {#if focussed_hour && focussed_day == day}\n              <WeatherInfo period={focussed_hour} />\n            {:else}\n              <WeatherInfo period={day} />\n            {/if}\n            <!-- {#if day.temp_line_chart}\n              <div class=\"temperature_line_graph\">\n                {#each day.temp_line_chart as temp, t1}\n                  <div\n                    class=\"temp\"\n                    style:top={`${temp.oldy}%`}\n                    style:left={`${temp.oldx}%`}\n                    style:width={`${temp.length}%`}\n                    style:transform={`rotate(${temp.theta}deg)`}\n                  >\n                    {temp.value}\n                  </div>\n                {/each}\n              </div>\n            {/if}\n            -->\n            {#if day.temp_bar_chart}\n              <div class=\"rain_thing\">\n                <ul class=\"temperature_bar_chart\">\n                  {#each day.temp_bar_chart as temp, t1}\n                    <li\n                      class=\"temp\"\n                      title={`${temp.value}°`}\n                      class:focussed={temp.hour === focussed_hour}\n                      style:height={`${temp.height}%`}\n                    >\n                      {#if temp.rt}\n                        <span class=\"record_temp\">{temp.rt}</span>\n                      {/if}\n                    </li>\n                  {/each}\n                </ul>\n              </div>\n            {/if}\n\n            {#if day.temp_svg}\n              <div class=\"rain_thing\">\n                <svg\n                  on:mousemove={(e) => focusOnHourByPos(e, day)}\n                  on:touchmove={(e) => focusOnHourByPos(e, day)}\n                  class=\"sun_line_chart\"\n                  height={svg_height}\n                  width=\"100\"\n                  viewBox=\"0 0 100 {svg_height}\"\n                  preserveAspectRatio=\"none\"\n                >\n                  <polyline points={day.temp_svg.polyline} />\n                  {#each day.temp_svg.polygons as polygon}\n                    <polygon\n                      points={polygon.points}\n                      class:focussed={polygon.hour === focussed_hour}\n                    />\n                  {/each}\n                  <!-- {#each day.temp_svg.texts as text}\n                    <text x={text.x} y={text.y}>{text.text}</text>\n                  {/each} -->\n                </svg>\n              </div>\n            {/if}\n\n            {#if day.hours.length > 4}\n              <div class=\"rain_thing\">\n                <ul class=\"rain_chance_graph\">\n                  {#each day.hours as hour, h1}\n                    <li\n                      title={`${hour.pop * 100}%`}\n                      style:height={`${hour.pop * 100}%`}\n                    >\n                      {#if h1 % Math.ceil(day.hours.length / 4) == 0}\n                        <span>{constants.timeToHour(hour.dt)}</span>\n                      {/if}\n                    </li>\n                  {/each}\n                </ul>\n              </div>\n            {:else}\n              <div\n                class=\"rain_thing rain_probability\"\n                title={`${day.pop * 100}%`}\n              >\n                <div class=\"rain_inner\" style:width={`${day.pop * 100}%`}></div>\n              </div>\n            {/if}\n          </div>\n          <!-- end of .day -->\n        {/if}\n      {/each}\n    </section>\n\n    <section>\n      <div class=\"button_group\">\n        {#each constants.available_locations as loc}\n          <a\n            href=\"#location\"\n            on:click={() => chooseLocation(loc)}\n            class:primary={loc == location.name}\n            class=\"button\">{loc}</a\n          >\n        {/each}\n      </div>\n    </section>\n  {:else}\n    <div class=\"loading\"></div>\n  {/if}\n\n  <svg>\n    <linearGradient id=\"Gradient1\" x1=\"0\" x2=\"0\" y1=\"0\" y2=\"1\">\n      <stop stop-color=\"#ddbf48\" offset=\"0%\" />\n      <stop stop-color=\"#ddbf48\" stop-opacity=\"0.1\" offset=\"100%\" />\n    </linearGradient>\n  </svg>\n</div>\n\n<style>\n  svg {\n    background-color: red;\n  }\n</style>\n"
  ],
  "names": [],
  "mappings": "AAsbE,kBAAI,CACF,gBAAgB,CAAE,GACpB"
}